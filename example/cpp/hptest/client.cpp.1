#include "common.hpp"

enum class Mode {
    NONE,
    REUSE_ADDR,  // reuse address after connectiong to 3rd party
    SIM_OPEN,    // simultaneous open on next port
    BOTH,        // REUSE_ADDR + SIM_OPEN
};

Mode parseMode(const std::string& str)
{
    if (str == "r") return Mode::REUSE_ADDR;
    if (str == "s") return Mode::SIM_OPEN;
    if (str == "b") return Mode::BOTH;
    throw std::domain_error("Unknown mode: " + str);
}

int main(int argc, char **argv)
{
    std::string host((argc > 1) ? argv[1] : "localhost");
    int port = (argc > 2) ? std::stoi(argv[2]) : 6666;
    Mode mode = parseMode((argc > 3) ? argv[3] : "r");

    struct sockaddr_in selfAddr, peerAddr;
    {
        TcpSocket medSock(nullptr, true);
        auto medAddr = sockAddrIn(port, host);
        medSock.connect(medAddr);

        medSock.address(&selfAddr);
        if (!medSock.read(&peerAddr))
            throw std::domain_error("could not read peer address");

        std::cout << "Self address: " << selfAddr << std::endl;
        std::cout << "Peer address: " << peerAddr << std::endl;
    }

    if (mode != Mode::REUSE_ADDR) {
        selfAddr.sin_port = htons(ntohs(selfAddr.sin_port) + 1);
        peerAddr.sin_port = htons(ntohs(peerAddr.sin_port) + 1);
    }

    TcpSocket inSock(&selfAddr, true);
    std::thread inThread([&]()
    {
        try {
            int data = 1;
            inSock.listen();
            while (true) {
                struct sockaddr_in peerAddrIn;
                TcpSocket peer(inSock, &peerAddrIn);

                if (peer.write(++data))
                    std::cout << peerAddrIn << "Sent: " << data << std::endl;
                else
                    std::cerr << peerAddrIn << "Sending failure" << std::endl;
            }
        } catch (std::exception& ex) {
            std::cerr << "Error: " << ex.what() << std::endl;
        }
    });

    TcpSocket outSock(mode == Mode::SIM_OPEN ? 0 : &selfAddr, true);
    std::thread outThread([&]()
    {
        try {
            int data;
            outSock.connect(peerAddr);
            std::cout << "Connected to: " << peerAddr << std::endl;

            if (outSock.read(&data))
                std::cout << "Read: " << data << std::endl;
            else
                std::cerr << "Reading failure" << std::endl;
        } catch (std::exception& ex) {
            std::cerr << "Error: " << ex.what() << std::endl;
        }
    });

    inThread.join();
    outThread.join();
}
